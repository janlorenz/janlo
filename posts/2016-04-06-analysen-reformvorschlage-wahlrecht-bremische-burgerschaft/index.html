<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2016-04-06">

<title>Analysen und Reformvorschläge zum Wahlrecht zur Bremischen Bürgerschaft – Jan Lorenz</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-34f7cc368464e0fe4b62d8d4059141d4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Jan Lorenz</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cv.html"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../scientific-events.html"> 
<span class="menu-text">Scientific Events</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../constructor-labs.html"> 
<span class="menu-text">Constructor Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Analysen und Reformvorschläge zum Wahlrecht zur Bremischen Bürgerschaft</h1>
  <div class="quarto-categories">
    <div class="quarto-category">data-analysis</div>
    <div class="quarto-category">deutsch</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 6, 2016</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Dieser Text argumentiert für&nbsp;diesen&nbsp;<a href="https://docs.google.com/document/d/1EeDf1BGWRaF2oLRkzOOPl30YgDullOL18Eo_Mphz9jg/edit?usp=sharing"><strong>Reformvorschlag</strong></a>.</p>
<p>Der Weser-Kurier <a href="#1">[1]</a> schrieb im Februar 2016, <strong>SPD und CDU wollten möglichst zügig ein neues Wahlrecht in der Bürgerschaft verabschieden</strong>.&nbsp;Neben Heilungsregeln für zur Zeit ungültige Wahlzettel geht es vor allem um zwei Dinge:</p>
<p><strong>1. Es sollen die Hälfte der Mandate einer Partei per Parteiliste und die andere Hälfte per Wählerrangliste nach Personenstimmen vergeben werden.</strong> Das Verhältnis soll nicht mehr, wie jetzt, durch das Verhältnis von Personen- und Listenstimmen bestimmt werden.</p>
<p><strong>2. Es soll zuerst die Wählerrangliste und dann die Parteiliste abgearbeitet werden.</strong>&nbsp;Derzeit ist es anders herum. Als Grund wird genannt, dass die Personenbank eigentlich hauptsächlich durch die Spitzenkandidat_innen “überhand” genommen hätte und dass dadurch auch einige Kandidiernde&nbsp;in die Bürgerschaft kamen, für die nur wenige hundert Stimmen abgegeben worden wären. [Update 26.5.2016: Inzwischen haben sich auch DIE LINKE&nbsp;<a href="#5">[5]</a>&nbsp;und GRÜNE&nbsp;<a href="#6">[6]</a>&nbsp;auf Landesparteitagen für die Umkehrung der Reihenfolge aber gegen die starre hälftige Aufteilung ausgesprochen.]</p>
<p><strong>In diesem Beitrag stelle ich eine neue <a href="https://docs.google.com/spreadsheets/d/1O0aVHYYX6W5Lzm8BIncARW77Fa-Txdzv5zbdvaNrHY8/pubhtml">detailiertere Analyse der Wahldaten</a> von 2015 vor, sowie zum Vergleich die gleiche Analyse&nbsp;zur Wahl 2011.</strong> <!--more-->Damit möchte ich zu einer informierteren Bewertung der Lage auch im Detail (z.B. auf Kandidierenden-Ebene) beitragen. Die Analyse, sowie auch dieser Artikel kann kommentiert werden. Kurz zusammengefasst: Die durch die Personenstimmen erzeugte Wählerrangliste der Kandidierenden&nbsp;und von den Parteimitgliedern festgelegt Parteilisten sind bei allen in der Bürgerschaft vertretenen Parteien sehr&nbsp;ähnlich und bei weitem nicht gegensätzlich. Gleichzeitig gibt es einen Trend zu mehr Personenstimmen, deren Anteil aber trotzdem noch unter 50% liegt. Gleichzeitig wurden aber der Stimmenanteil der Spitzenkandidat_innen weniger (von 19.1% auf 18.5%), insbesondere bei der Bürgermeister-Partei SPD (von 32.8% auf 28.6%) und das trotz eines Wahlkampfes der stark auf die Spitzenkandidat_innen fokussierte. <strong>Die Personenwahlmöglichkeiten des neuen Wahlrechts werden also durch die Wählenden sowohl mehr als auch kompetenter genutzt.</strong>&nbsp;Da Parteiliste und Wählerrangliste ähnlich sind, geht es mit der Umkehrung der Reihenfolge praktisch um die Frage, welcher Liste der Vorrang bei den “unsicheren” Mandaten gegeben werden soll. Modellrechnungen zeigen hier, dass nach dem neuen Vorschlag nur noch 10.8% der Abgeordneten abweichend von den Parteilisten in die Bürgerschaft einzögen. Derzeit sind es 26.5%. Würde nur die Rangliste der Wählenden benutzt, wären es kaum mehr, nämlich 31.3%. <strong>Parteien und Wähler sind sich also zur Zeit schon&nbsp;eher einig als uneinig, weshalb es hier eigentlich konsequent&nbsp;und politisch machbar erscheint, ganz auf den Wählerwillen auch bei den Personen zu setzen.</strong></p>
<p>Die&nbsp;<a href="https://docs.google.com/spreadsheets/d/1O0aVHYYX6W5Lzm8BIncARW77Fa-Txdzv5zbdvaNrHY8/pubhtml">Datenanalyse</a>&nbsp;zeigt allerdings auch die Relevanz einer bisher weniger beachteten&nbsp;Eigenschaft des Bremer Wahlsystems: <strong>Es gibt&nbsp;Kandidierenden gut Chancen, die auf viele Personenstimmen von vergleichsweise wenigen Wählenden setzen. Dadurch haben es Kandidierende schwerer, die mehr Wählende ansprechen, aber von denen eher nur eine Stimme erhalten.</strong> Beispielsweise wird eine Kandidatin, die von nur 300 Wählenden alle fünf Stimmen bekommt, genauso eingeordnet wie eine Kandidatin die von 1500 Wählenden je eine Stimme bekommt. Tatsächlich gibt es in der Bürgerschaft Kandidierende, die eher dem einen oder eher dem anderen Typ entsprechen. Es zeigt sich allerdings ein Trend in Richtung des ersten Typs. Auch die Wählenden stehen vor der Frage, ob sie nicht aus rein strategischen Gründen alle Stimmen auf einen Kandidierenden kummulieren sollen. Der Anreiz strategisch zu wählen ist besonders stark gerade für die Wählenden, die sich viel über Kandidierende informieren und schon eine Liste von fünf&nbsp;Favoriten abseits der bekannten Gesichter also auf unsicheren Plätzen haben. Dies scheint mir eigentlich nicht “im Sinne der Erfinder” zu sein. Langfristig verstärkt die Möglichkeit alle fünf Stimmen zu kummulieren, glaube ich, Polarisierungstendenzen sowohl in den Fraktionen der Bürgerschaft, als auch in der Bevölkerung. <strong>Ein neuer&nbsp;<a href="https://docs.google.com/document/d/1EeDf1BGWRaF2oLRkzOOPl30YgDullOL18Eo_Mphz9jg/edit#heading=h.aehyqs7ax4xa">Vorschlag</a> für eine Wahlrechtsreform ist daher: Einerseits ganz auf die Wählerrangliste zu setzen, aber dafür andererseits auf die Anzahl der Wähler und nicht die Anzahl der Stimmen zu setzen.</strong>&nbsp;In der Umsetzung würde dies bedeuten, dass man als Wählender jedem Kandidierenden maximal eine Stimme geben kann, aber weiterhin fünf Stimmen (oder perspektivisch sogar mehr) abgeben kann.</p>
<p>Das aktuelle Wahlrecht, den Vorschlag von SPD und CDU, sowie den neuen Vorschlag vergleicht folgende Tabelle:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: center;"><strong>Aktuelles Wahlrecht</strong></th>
<th style="text-align: center;"><strong>Vorschlag A &nbsp;(SPD/CDU)</strong></th>
<th style="text-align: center;"><strong>Vorschlag B (Neu)</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Anzahl Mandate per Wählerrangliste</td>
<td style="text-align: center;">Nach Anteil der Personen-stimmen an Gesamtstimmen</td>
<td style="text-align: center;">50.00%</td>
<td style="text-align: center;">Alle</td>
</tr>
<tr class="even">
<td style="text-align: left;">Unsichere Mandate vergeben nach</td>
<td style="text-align: center;">Wählerrangliste</td>
<td style="text-align: center;">Parteiliste</td>
<td style="text-align: center;">Wählerrangliste</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Wieviele Stimmen maximal pro Kandidat_in</td>
<td style="text-align: center;">5 von 5</td>
<td style="text-align: center;">5 von 5</td>
<td style="text-align: center;">1 von 5</td>
</tr>
<tr class="even">
<td style="text-align: left;">Personenstimmenparadox</td>
<td style="text-align: center;">Ja</td>
<td style="text-align: center;">Nein</td>
<td style="text-align: center;">Nein</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Mandatsrelevanz der Personenstimmen 2015</td>
<td style="text-align: center;">26.50%</td>
<td style="text-align: center;">10.80%</td>
<td style="text-align: center;">26.50%</td>
</tr>
</tbody>
</table>
<p>Das Personenstimmenparadox wird hier nur erwähnt, weil es einen gewissen verfassungsmäßig gebotenen Reformbedarf erzeugt. Es wurde von Valentin Schröder und Lothar Probst&nbsp;<a href="#2">[2,3]</a>&nbsp;zu recht problematisiert. In ihren Lösungsvorschlägen&nbsp;<a href="#3">[3]</a> fehlt allerdings die Lösung, ganz auf die Reihenfolge der Wählenden zu setzen.</p>
<p>Die Datenanalyse bietet <strong>Modellrechnungen</strong> inklusive den hypothetisch dann gewählten Personen für alle drei Wahlsystem (die Links öffnen die Ergebnisse in Google Spreadsheet): <a href="https://docs.google.com/spreadsheets/d/1O0aVHYYX6W5Lzm8BIncARW77Fa-Txdzv5zbdvaNrHY8/edit#gid=692618892">Aktuelles Wahlrecht 2015</a> <a href="https://docs.google.com/spreadsheets/d/1O0aVHYYX6W5Lzm8BIncARW77Fa-Txdzv5zbdvaNrHY8/edit#gid=1916215620">Reformvorschlag A: 50/50, Personenrangliste zuerst 2015</a> <a href="https://docs.google.com/spreadsheets/d/1O0aVHYYX6W5Lzm8BIncARW77Fa-Txdzv5zbdvaNrHY8/edit#gid=1532329419">Reformvorschlag B: Wähleranzahlrangliste 2015</a> Hinweis: Die Ergebnisse beziehen sich auf die Zählung noch vor der <a href="http://www.verwaltungsgericht.bremen.de/sixcms/media.php/13/15_1330_K_14.pdf">Entscheidung des Bremer Wahlprüfungsgerichts</a>&nbsp;das Ergebnis zu korregieren. Bei den Listen der potentiellen Mitglieder der Bremischen Bürgerschaft sind Mandatsniederlegungen und Nachrückungen auch nicht berücksichtigt.</p>
<p>Der <strong>Unterschied der drei Systeme</strong> lässt sich an dem interessanten <strong>Beispiel der Grünen-Liste in Bremerhaven</strong> erläutern. Die Grünen errangen dort zwei Mandate, nach aktuellem Wahlrecht wird davon einer nach der Parteiliste und einer nach der Wählerrangliste vergeben. Das gleiche wäre im Falle von Vorschlag A der Fall. Bei Vorschlag B würden beide Mandate nach der Wählerrangliste vergeben werden.&nbsp;Sülmez Dogan ist auf Platz 1 der Liste und führt&nbsp;mit&nbsp;3058 Personenstimmen von 1318 Wählenden sowohl die Wählerrangliste nach Personenstimmen, als auch die nach de Anzahl der Wählenden an. D.h. sie erhält nach allen drei Systemen das erste Mandat. Nach aktuellem Wahlrecht bekommt sie das Listenmandat, nach Vorschlag A das Personenmandat. Spannend wird es bei Platz zwei. Nach aktuellem Wahlrecht, bekam Turhal Özdal das Personenstimmenmandat da er mit&nbsp;837 die zweitmeisten Personenstimmen hat. Da er nur auf Listenplatz neun steht wäre er nach Vorschlag A abgeschlagen für den Listensitz, den würde Frank Willmann bekommen der auf Platz zwei steht aber nur 715 Stimmen hat. Auch nach Vorschlag B wäre Özdal nicht gewählt, da sechs Listenmitglieder ihre (weniger) Stimmen von mehr Wählenden haben. Gewählt wäre Ulf Eversberg, der zwar nur&nbsp;737 Stimmen hat, diese kommen aber von 424 Wählenden. Turhal Özdal ist inzwischen bei den Grünen ausgetreten und der Fraktion der CDU beigetreten. Dies ist&nbsp;sein legitimes Recht, er hat es darüber hinaus auch Forderungen der Grünen, sein Mandat niederzulegen, mit der Begründung zurückgewiesen, dass er über Personenstimmen gewählt sei&nbsp;<a href="#4">[4]</a>. [Update 26.5.2016: Die Spitzenkandidatin und Finanzsenatorin der GRÜNEN Karoline Linnert wird im Weser-Kurier <a href="#6">[6]</a> zitiert “das geltende Wahlrecht befördere die ‘Partikularinteressen von Ethnien, Cliquen und Peer-Groups’.” Das ist eine drastischere Interpretation von Polarisierungstendenzen. Der Vorschlag der GRÜNEN die Reihenfolge der Zuteilung umzukehren, befördert Polarisierungstendenzen aber weiter, da er nichts an den strategischen Anreizen für Wählende und Kandidierende ändert alle 5 Stimme geschlossen abzugeben bzw. einzuwerben.]</p>
<p><strong>Fazit:</strong> Das Bremer Wahlrecht neigt möglicherweise dazu, Polarisierungstendenzen in Fraktionen und Bevölkerung zu verstärken. Innerhalb der Fraktionen ist&nbsp;dies auch schon beobachtbar, weshalb es Bestrebungen&nbsp;zumindest bei SPD, CDU, Grünen und Linken gibt, den Einfluss der Wählenden wieder faktisch deutlich&nbsp;zurück zu drehen, obwohl die Wählenden ihn zunehmend und kompetenter nutzen. Ein besserer Reformansatz wäre, an der Anzahl der Kummuliermöglichkeiten für Personenstimmen anzusetzen. Auch aus normativen Gründen ist es nicht unbedingt&nbsp;konsequent&nbsp;alle Stimmen für einen&nbsp;Kandidierenden im Wahlsystem&nbsp;anzubieten. Es soll schließlich&nbsp;ein Parlament gewählt werden und nicht eine Person. Die Personenstimme ist hauptsächlich eine Stimme für die Liste der sich der Kandidierende angeschlossen hat und erst im zweiten Schritt Bekenntnis der besonderen Zustimmung zu dieser Person. Das aktuelle Wahlrecht war gut, da es den Wählenden die bekannte reine Listenwahl gelassen hat. Auch die fünf Kummuliermöglichkeiten haben sicherlich schnell&nbsp;“Schwung” in die Parteilisten gebracht in dem es gezeigt hat, dass dort für Wählende und Kandidierende etwas möglich ist.&nbsp;Jetzt sollte das Wahlrecht weiterentwickelt werden in dem die Polarisierungsverstärkung abgebaut wird&nbsp;ohne den Einfluss der Wählenden zurückzudrehen. Zum Beispiel mit diesem einfachen&nbsp;<a href="https://docs.google.com/document/d/1EeDf1BGWRaF2oLRkzOOPl30YgDullOL18Eo_Mphz9jg/edit#heading=h.aehyqs7ax4xa">Vorschlag</a>.</p>
<p>&nbsp;</p>
<p>[1] <a href="http://www.weser-kurier.de/bremen/bremen-politik-wirtschaft_artikel,-SPD-und-CDU-wollen-Wahlrechtsreform-vorantreiben-_arid,1316733.html">SPD und CDU wollen Wahlrechtsreform vorantreiben</a>, Jürgen Theiner, <em>Weser-Kurier</em>, 19.2.2016 [2]&nbsp;<a href="http://dx.doi.org/10.5771/0340-1758-2015-3-561">Fremdverwertung und Personenstimmenparadox: Negatives Stimmgewicht im Bremer und Hamburger Bürgerschaftswahlrecht</a>,Valentin Schröder,&nbsp;<em>Zeitschrift für Parlamentsfragen</em>, <strong>2015</strong>_, 46_, 561-577 [3] <a href="http://www.lotharprobst.de/fileadmin/user_upload/redakteur/Aktuelles/2015/Effekte_Wahlsystem_2015.pdf">Das Bremer Wahlsystem: Intransparent, paradox und möglicherweise verfassungswidrig</a>, Lothar Probst, Valentin Schröder,&nbsp;Institut für Politikwissenschaft, Universität Bremen [4]&nbsp;<a href="http://www.radiobremen.de/politik/themen/oezdal-wechselt100.html">Ex-Grüner will zur CDU</a>, Radio Bremen 20. Februar 2016 [5]&nbsp;<a href="http://www.dielinke-bremen.de/nc/politik/aktuell/detail/browse/1/zurueck/bremennews/artikel/landesparteitag-kritisiert-festhalten-des-senats-an-schuldenbremse-und-diskutiert-moegliche-wahlrech/">Landesparteitag kritisiert Festhalten des Senats an Schuldenbremse und diskutiert mögliche Wahlrechtsreform</a>, DIE LINKE Landesverband Bremen, 25.4.2016 [6]&nbsp;<a href="http://www.weser-kurier.de/bremen_artikel,-Gruene-fuer-Wahlrechtsreform-_arid,1369422.html">Grüne für Wahlrechtsreform</a>,&nbsp;Jürgen Theiner, <em>Weser-Kurier</em>, 4.5.2016</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/www\.janlo\.de");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
  });
  </script>
</div> <!-- /content -->




</body></html>