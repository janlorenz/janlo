<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2015-05-31">

<title>Modellrechnungen Wahlrecht zur Bremischen Bürgerschaft – Jan Lorenz</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-34f7cc368464e0fe4b62d8d4059141d4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Jan Lorenz</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cv.html"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../scientific-events.html"> 
<span class="menu-text">Scientific Events</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../constructor-labs.html"> 
<span class="menu-text">Constructor Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#vier-modifikationen-und-alte-listenwahl-zum-vergleich" id="toc-vier-modifikationen-und-alte-listenwahl-zum-vergleich" class="nav-link active" data-scroll-target="#vier-modifikationen-und-alte-listenwahl-zum-vergleich">Vier Modifikationen (und alte Listenwahl zum Vergleich)</a></li>
  <li><a href="#fazit-alles-nach-personenstimmen-ist-am-einfachsten" id="toc-fazit-alles-nach-personenstimmen-ist-am-einfachsten" class="nav-link" data-scroll-target="#fazit-alles-nach-personenstimmen-ist-am-einfachsten">Fazit: Alles nach Personenstimmen ist am einfachsten</a></li>
  <li><a href="#besser-das-schweizer-wahlsystem-ohne-kreuze" id="toc-besser-das-schweizer-wahlsystem-ohne-kreuze" class="nav-link" data-scroll-target="#besser-das-schweizer-wahlsystem-ohne-kreuze">Besser das Schweizer Wahlsystem ohne Kreuze?</a></li>
  <li><a href="#weitere-alternative-maximal-2-kreuze-pro-kandidat" id="toc-weitere-alternative-maximal-2-kreuze-pro-kandidat" class="nav-link" data-scroll-target="#weitere-alternative-maximal-2-kreuze-pro-kandidat">Weitere Alternative: Maximal 2 Kreuze pro Kandidat</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Modellrechnungen Wahlrecht zur Bremischen Bürgerschaft</h1>
  <div class="quarto-categories">
    <div class="quarto-category">deutsch</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 31, 2015</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Nach der Wahl zur&nbsp;Bremischen Bürgerschaft 2015 gibt es Diskussionen zur Änderung des Wahlrechts. Neben Artikeln und Berichten von Weser-Kurier, Radio Bremen und taz ist hier ein relevanter Debattenbeitrag von Lothar Probst und Valentin Schröder&nbsp;<a href="http://www.lotharprobst.de/fileadmin/user_upload/redakteur/Aktuelles/2015/Effekte_Wahlsystem_2015.pdf">http://www.lotharprobst.de/fileadmin/user_upload/redakteur/Aktuelles/2015/Effekte_Wahlsystem_2015.pdf</a>. Kritischster Punkt ist&nbsp;das sog. Personenstimmenparadoxon: Ein Wackelkandidat verliert sein Listenmandat, weil für ihn abgegebene Personenstimmen das Personenstimmenkontigent zu Lasten des Listenstimmenkontingents vergrößern. Er hat aber nicht genug Personenstimmen, um über das Personenstimmenkontingent ein Mandat zu bekommen. So hat jemand der ihn als Person gewählt hat, ihm eigentlich “geschadet”, da er ihn möglicherweise hätte nutzen können wenn er statt ihn seine Liste gewählt hätte. So geschehen mit Thomas von Bruchs, siehe&nbsp;<a href="http://www.taz.de/Paradoxien-des-Bremer-Wahlsystems/!5201700/">http://www.taz.de/Paradoxien-des-Bremer-Wahlsystems/!5201700/</a>&nbsp;.</p>
<p>Hier stelle ich alternative Wahlergebnisse der Wahl 2015 für vier Modifikationen des Bremer Wahlrechts zur Verfügung sowie die Ergebnisse nach reiner Listenwahl, um die Relevanz der Veränderungen bei aktuellem Wahlverhalten beurteilen zu können. Im Anschluss gebe ich meine Einschätzung, wie das Bremer Wahlrecht weiter entwickelt werden sollte: Mehr Stimmen, weniger Kummulieren, einfachere Stimmabgabe (ohne Kreuze). <!--more--></p>
<section id="vier-modifikationen-und-alte-listenwahl-zum-vergleich" class="level1">
<h1>Vier Modifikationen (und alte Listenwahl zum Vergleich)</h1>
<p>Die Ergebnisse mit den Namen der hypothetischen Abgeordneten finden sich hier&nbsp;<a href="https://docs.google.com/spreadsheets/d/1YvxQmoP82OOt04tAEo92Na37RH1nx9Jp6XsNFq9d8Bk/edit?usp=sharing">https://docs.google.com/spreadsheets/d/1YvxQmoP82OOt04tAEo92Na37RH1nx9Jp6XsNFq9d8Bk/edit?usp=sharing</a>.</p>
<p>Die Modelle sind die folgenden:</p>
<p><strong>Modell 0.</strong> Die Sitze zugeteilt nach aktuellem Wahlrecht. Für eine Liste werden zuerst die Mandate nach Liste vergeben, danach die Mandate in der Reihenfolge der Personenstimmen an alle Kandidaten die noch kein Mandat haben.</p>
<p><strong>Modell 1.</strong>&nbsp;Es werden zuerst die Mandate nach Personenstimmen vergeben und dann die Mandate nach Listenstimmen an alle die noch kein Mandat haben (wie bei den Niedersächsischen Kommunalwahlen).</p>
<p><strong>Modell 2.</strong>&nbsp;Es wird festgelegt, dass 50% der Sitze über die Liste vergeben werden und 50% über die Personenstimmenrangliste, wobei zuerst die Personenstimmenrangliste abgearbeitet wird, danach die Liste. Bei einer ungeraden Anzahl an Gesamtmandaten habe ich eine Stimme mehr für die Personenrangliste vorgesehen.</p>
<p><strong>Modell 3.</strong>&nbsp;Es wird festgelegt, dass 50% der Sitze über die Liste vergeben werden und 50% über die Personenstimmenrangliste, wobei umgekehrt zu Modell 2 zuerst die Liste abgearbeitet wird, danach diePersonenstimmenrangliste.</p>
<p><strong>Modell 4.</strong> Alle Plätze werden nur nach der Personenstimmenrangliste vergeben.</p>
<p><strong>Modell 5.</strong> Alle Plätze werden nur nach der Liste&nbsp;vergeben. Zum Vergleich.</p>
<p>Aufgrund dieser Berechnungen mag jemand anders gerne Frauen-, Migrationshintergrundsquoten usw. auswerten. Die Ergebnisse würden mich interessieren. (Edit 15.6.2015: Inzwischen passiert in der Pressemitteilung von Mehr Demokratie e.V. in einer Analyse von Paul Tiefenbach <a href="http://bremen-nds.mehr-demokratie.de/hbnds_nachrichten.html?&amp;no_cache=1&amp;tx_ttnews%5BbackPid%5D=6832&amp;tx_ttnews%5Btt_news%5D=16315&amp;cHash=695e15e8e9d09a0a73048356108a7912">http://bremen-nds.mehr-demokratie.de/hbnds_nachrichten.html?&amp;no_cache=1&amp;tx_ttnews%5BbackPid%5D=6832&amp;tx_ttnews%5Btt_news%5D=16315&amp;cHash=695e15e8e9d09a0a73048356108a7912</a> .)</p>
</section>
<section id="fazit-alles-nach-personenstimmen-ist-am-einfachsten" class="level1">
<h1>Fazit: Alles nach Personenstimmen ist am einfachsten</h1>
<p>Ich habe noch keine abschließende Einschätzung welche weiteren Paradoxien diese Modifikationen beinhalten. Das Personenstimmenparadox kann in den Modellen 0 und 1 auftreten. Derzeitg wäre wohl Modell 4 die einfachste und transparenteste Lösung. Meine derzeitigen Überlegungen sind:</p>
<ul>
<li>In Modellen 1-3 sehe ich keinen wirklichen Zugewinn an Transparenz im Vergleich zu Modell 0.</li>
<li>In den Modellen 1 und 2 (Personenrangliste vor Liste) sehe ich einen starken Verlust des Wertes der Personenstimme für den sich die Bürger ja eindeutig per Volksbegehren entschieden haben. Personenstimmen werden stark genutzt. Die Nutzung ist angestiegen. Diese Modelle würden die Macht über das Personal der Parlamentszusammensetzung wieder deutlich zurück in die Parteien verlagern. Modell 5 sehe ich aus diesen Gründen nicht wirklich als realistische Option. Das Personenstimmenparadox ist nicht so schwerwiegend oder unlösbar, als dass auf den per Volksbegehren erreichten Grundsatz, der Verknüpfung der Verhältniswahl mit einer Personenwahl verzichtet werden könnte.</li>
<li>Die Bevorzugung von (alten) Männern durch die Personenstimmen der Wählen scheint vor allem bei Wählern der SPD aufzutreten. Dazu habe ich noch einen nicht statistisch quantifizierten Eindruck von meiner Tätigkeit als Wahlhelfer: Es gibt einige Wahlzettel auf denen alle fünf Stimmen auf&nbsp;&nbsp;5 verschiedene Personen von mittleren und hinteren Listenplätzen vergeben wurden. Diese Personen sind aber fast immer alle bei der gleichen Liste. Ich glaube da wählen Leute, die die Personen, in der Partei alle gut kennen und spezielle Leute fördern wollen. Dies scheint Männern insbesondere in der SPD intern etwas besser zu gelingen.</li>
<li>Ein kaum&nbsp;betonter Aspekt in der Debatte ist, dass Personenstimmen ja auch Stimmen für die Liste sind, die die Liste ja vielleicht sonst gar nicht bekommen hätte. Das ist zumindest bei meiner Wahlentscheidung der Fall. D.h. Thomas von Bruchs (CDU) hat jetzt zwar ziemlich Pech gehabt und seine Wähler hätten tatsächlich taktisch besser die Liste CDU statt ihn gewählt, aber wer weiß ob seine Wähler überhaupt die CDU ohne ihn Wählen wollten? Durch Personenstimmen wird ein Kandidat für die Parteien interessanter.</li>
</ul>
</section>
<section id="besser-das-schweizer-wahlsystem-ohne-kreuze" class="level1">
<h1>Besser das Schweizer Wahlsystem ohne Kreuze?</h1>
<p>Ich meine, dass Bremer Wahlsystem sollte in die Richtung des Wahlsystem zum Schweizer Nationalrat weiter entwickelt werden. Damit könnte man mehrere Probleme und Interessen auf einmal befriedigen. Im Schweizer Wahlsystem hat man soviele Stimmen wie Leute die gewählt werden (also 68 für den Wahlbezirk Bremen, 15 für den Wahlbezirk Bremerhaven). <strong>Man macht aber keine Kreuze!</strong>&nbsp;Stattdessen hat man alle Listen (in Bremen ca. 10 bis 11) vorliegen und sucht sich eine aus. Wenn man es einfach macht, gibt man sie einfach ab und wählt damit jede Person auf der Liste genau einmal (und die Liste analog zum Bremer Wahlsystem 68mal). Alles ganz genau wie früher. Wer mehr will verändert den Wahlzettel. Man kann Kandidaten durchstreichen und dann die Nummern von anderen Kandidaten (auch von anderen Listen = panaschieren) eintragen. Dabei darf man auch kummulieren (also eine Person nochmal eintragen) aber nur einmal. Man kann also nicht 68 Stimmen einer Person geben. Auch trotz der erstmal gigantisch und aufwendig klingenden Zahl von 68 Stimmen für den Wahlbezirk Bremen ergeben sich dadurch viele Vorteile:</p>
<ul>
<li>Durch die einfache Abgabe der Listen und die Beschränkung auf maximal zwei Stimmen pro Kandidaten wird der Spitzenkandidateneffekt (der das Personenstimmenparadox erst wirksam macht) deutlich abgemildert und die Bedeutung der Liste gestärkt.</li>
<li>Der Wähler kann seinen Willen noch deutlich genauer ausdrücken und zum Beispiel seine 68 Abgeordneten aussuchen. <strong>Mir reichen die fünf Stimmen zum Beispiel überhaupt nicht aus, schließlich habe ich zu vielen Kandidaten eine Meinung, ob sie kompetent im Parlament arbeiten können und gute Entscheidungen für Bremen treffen werden!</strong>&nbsp;Das schöne: Keiner muss sich 68 Leute aussuchen oder 68 Kreuze machen. Jeder kann das nach seinem Kenntnisstand und Wunsch machen und zum Beispiel nur 2-3 andere auf der Liste seiner präferierten Partei eintragen.</li>
<li>Trotz der 68 Stimmen sollte das Auszählen immernoch deutlich einfacher sein als jetzt. Man hat dann pro Wahlzettel nur eine Liste abzuarbeiten und muss nicht ein ganzes Heft zweimal durchblättern. Da viele Listen unverändert sein werden, geht es viel schneller, denn ein Heft mit 5 Kreuzen bei Liste&nbsp;SPD muss ja trotzdem einmal komplett durchgeblättert werden, bevor es gezählt werden kann. Selbst 68 selbstgeschriebene Stimmen braucht man als Wahlhelfer einfach nur von der Liste in den Auswertungsrechner abtippen ohne fünfmal das Heft durchzublättern auf der Suche nach einem möglichen fünften Kreuz …</li>
</ul>
<p><strong>Zusammengefasst:</strong> Es ginge dann wieder einfacher zu wählen, man hat gleichzeitig mehr Wahlfreiheit, der Wert der&nbsp;Listen wird gestärkt (durch weniger kummulieren und mehr Stimmen) und das Auszählen sollte&nbsp;sich auch noch beschleunigen.</p>
</section>
<section id="weitere-alternative-maximal-2-kreuze-pro-kandidat" class="level1">
<h1>Weitere Alternative: Maximal 2 Kreuze pro Kandidat</h1>
<p>Wenn unbedingt Kreuze gemacht werden sollen (und die Wahlhelfer weiter “gequält” werden) böte zur Vereinfachung an, für alle Kandidaten nur noch zwei Ankreuzmöglichkeiten zur Verfügung zu stellen. Das sollte einerseits bewirken, dass mehr Spitzenkandidatenstimmen wieder zu den Listen wandern. Außerdem wird es dann nicht mehr so einfach mit&nbsp;wenigen Wählern, die alle fünf Kreuze machen, viele Personenstimmen zu holen. Das Heft wird auch gleich deutlich übersichtlicher. Es könnte auch den Effekt haben, dass die Wählenden noch etwas mehr Gedanken machen, welche Personen die Stimmen bekommen sollen, weil man dann nicht mehr stumpf fünf Stimmen an den Spitzenkandidaten geben kann.</p>
<p>Die Listenstimmen könnte man auch in diesem Fall abschaffen (jede Personenstimme bleibt ja auch immer eine Stimme für die Liste). Man könnte sie aber auch beibehalten und für die Listen weiterhin fünf Ankreuzmöglichkeiten bereitstellen. Das Personenstimmenparadox sollte dann wahrscheinlich immer noch möglich sein, es wird aber wohl viel unwahrscheinlicher, dass es in der Praxis auftritt, ist es ja (laut Probst und Schröder u) wohl 2011 auch nicht. Zur Sicherheit kann man den Vorschlag der “iterativen Mandatszuteilung” (5.3 in Probst und Schröder) ins Wahlgesetz aufnehmen.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/www\.janlo\.de");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
  });
  </script>
</div> <!-- /content -->




</body></html>